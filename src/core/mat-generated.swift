// Â© 2015 George King.
// Permission to use this file is granted in license-qk.txt.
// This file is generated by gen-mat.py.

// OpenGL claims to be row vs column major agnostic,
// defining matrices as "having translation components in the last n components."
// see https://www.opengl.org/archives/resources/faq/technical/transformations.htm

// however OpenGL is generally considered to be "column major",
// meaning that elements of columns are contiguous in memory.
// this is due to the use of column-major notation in the spec.

// this implementation follows that of GLKit, which is column-major.
// matrix elements are named with a (col, row) notation,
// e.g m23 indicates col=2, row=3,
// which in a 4x4 matrix is the 14th element in memory:
// (len * row) + col = (4 * 3) + 2 = 14


struct M2S: Printable {
  var m00, m01, m10, m11: F32
  init(_ m00: F32, _ m01: F32, _ m10: F32, _ m11: F32) {
    self.m00 = m00
    self.m01 = m01
    self.m10 = m10
    self.m11 = m11
  } // init with elements in column major order.

  init(_ c0: V2S, _ c1: V2S) {
    self.init(c0.x, c0.y, c1.x, c1.y)
  } // init with column vectors.

  var description: String { return "M2S(\(m00), \(m01), \(m10), \(m11))" }
  var c0: V2S { return V2S(m00, m01) }
  var c1: V2S { return V2S(m10, m11) }
  var r0: V2S { return V2S(m00, m10) }
  var r1: V2S { return V2S(m01, m11) }
  static let zero = M2S(0, 0, 0, 0)
  static let ident = M2S(1, 0, 0, 1)
  static func scale(x: F32, y: F32) -> M2S { return M2S(x, 0, 0, y) }

}

func +(l: M2S, r: M2S) -> M2S { return M2S(l.m00 + r.m00, l.m01 + r.m01, l.m10 + r.m10, l.m11 + r.m11) }
func -(l: M2S, r: M2S) -> M2S { return M2S(l.m00 - r.m00, l.m01 - r.m01, l.m10 - r.m10, l.m11 - r.m11) }
func *(m: M2S, s: F32) -> M2S { return M2S(m.m00 * s, m.m01 * s, m.m10 * s, m.m11 * s) }
func /(m: M2S, s: F32) -> M2S { return M2S(m.m00 / s, m.m01 / s, m.m10 / s, m.m11 / s) }

func *(l: M2S, r: M2S) -> M2S { return M2S(
  (l.m00 * r.m00) + (l.m10 * r.m01),
  (l.m01 * r.m00) + (l.m11 * r.m01),
  (l.m00 * r.m10) + (l.m10 * r.m11),
  (l.m01 * r.m10) + (l.m11 * r.m11)
)}

func *(l: M2S, r: V2S) -> V2S { return V2S(
  (l.m00 * r.x) + (l.m10 * r.y),
  (l.m01 * r.x) + (l.m11 * r.y)
)}

struct M2D: Printable {
  var m00, m01, m10, m11: F64
  init(_ m00: F64, _ m01: F64, _ m10: F64, _ m11: F64) {
    self.m00 = m00
    self.m01 = m01
    self.m10 = m10
    self.m11 = m11
  } // init with elements in column major order.

  init(_ c0: V2D, _ c1: V2D) {
    self.init(c0.x, c0.y, c1.x, c1.y)
  } // init with column vectors.

  var description: String { return "M2D(\(m00), \(m01), \(m10), \(m11))" }
  var c0: V2D { return V2D(m00, m01) }
  var c1: V2D { return V2D(m10, m11) }
  var r0: V2D { return V2D(m00, m10) }
  var r1: V2D { return V2D(m01, m11) }
  static let zero = M2D(0, 0, 0, 0)
  static let ident = M2D(1, 0, 0, 1)
  static func scale(x: F64, y: F64) -> M2D { return M2D(x, 0, 0, y) }

}

func +(l: M2D, r: M2D) -> M2D { return M2D(l.m00 + r.m00, l.m01 + r.m01, l.m10 + r.m10, l.m11 + r.m11) }
func -(l: M2D, r: M2D) -> M2D { return M2D(l.m00 - r.m00, l.m01 - r.m01, l.m10 - r.m10, l.m11 - r.m11) }
func *(m: M2D, s: F64) -> M2D { return M2D(m.m00 * s, m.m01 * s, m.m10 * s, m.m11 * s) }
func /(m: M2D, s: F64) -> M2D { return M2D(m.m00 / s, m.m01 / s, m.m10 / s, m.m11 / s) }

func *(l: M2D, r: M2D) -> M2D { return M2D(
  (l.m00 * r.m00) + (l.m10 * r.m01),
  (l.m01 * r.m00) + (l.m11 * r.m01),
  (l.m00 * r.m10) + (l.m10 * r.m11),
  (l.m01 * r.m10) + (l.m11 * r.m11)
)}

func *(l: M2D, r: V2D) -> V2D { return V2D(
  (l.m00 * r.x) + (l.m10 * r.y),
  (l.m01 * r.x) + (l.m11 * r.y)
)}

struct M3S: Printable {
  var m00, m01, m02, m10, m11, m12, m20, m21, m22: F32
  init(_ m00: F32, _ m01: F32, _ m02: F32, _ m10: F32, _ m11: F32, _ m12: F32, _ m20: F32, _ m21: F32, _ m22: F32) {
    self.m00 = m00
    self.m01 = m01
    self.m02 = m02
    self.m10 = m10
    self.m11 = m11
    self.m12 = m12
    self.m20 = m20
    self.m21 = m21
    self.m22 = m22
  } // init with elements in column major order.

  init(_ c0: V3S, _ c1: V3S, _ c2: V3S) {
    self.init(c0.x, c0.y, c0.z, c1.x, c1.y, c1.z, c2.x, c2.y, c2.z)
  } // init with column vectors.

  var description: String { return "M3S(\(m00), \(m01), \(m02), \(m10), \(m11), \(m12), \(m20), \(m21), \(m22))" }
  var c0: V3S { return V3S(m00, m01, m02) }
  var c1: V3S { return V3S(m10, m11, m12) }
  var c2: V3S { return V3S(m20, m21, m22) }
  var r0: V3S { return V3S(m00, m10, m20) }
  var r1: V3S { return V3S(m01, m11, m21) }
  var r2: V3S { return V3S(m02, m12, m22) }
  static let zero = M3S(0, 0, 0, 0, 0, 0, 0, 0, 0)
  static let ident = M3S(1, 0, 0, 0, 1, 0, 0, 0, 1)
  static func scale(x: F32, y: F32, z: F32) -> M3S { return M3S(x, 0, 0, 0, y, 0, 0, 0, z) }

  static func rotX(theta: F32) -> M3S { return M3S(
              1,           0,           0,
              0,  cos(theta),  sin(theta),
              0, -sin(theta),  cos(theta)
  )}

  static func rotY(theta: F32) -> M3S { return M3S(
     cos(theta),           0, -sin(theta),
              0,           1,           0,
     sin(theta),           0,  cos(theta)
  )}

  static func rotZ(theta: F32) -> M3S { return M3S(
     cos(theta),  sin(theta),           0,
    -sin(theta),  cos(theta),           0,
              0,           0,           1
  )}

  static func rot(#theta: F32, norm: V3S) -> M3S {
    let _cos = cos(theta)
    let _cosp = 1 - _cos
    let _sin = sin(theta)
    return M3S(
      _cos + _cosp * norm.x * norm.x,
      _cosp * norm.x * norm.y + norm.z * _sin,
      _cosp * norm.x * norm.z - norm.y * _sin,
      _cosp * norm.x * norm.y - norm.z * _sin,
      _cos + _cosp * norm.y * norm.y,
      _cosp * norm.y * norm.z + norm.x * _sin,
      _cosp * norm.x * norm.z + norm.y * _sin,
      _cosp * norm.y * norm.z - norm.x * _sin,
      _cos + _cosp * norm.z * norm.z
  )}

  static func rot(a: V3S, _ b: V3S) -> M3S {
    return rot(theta: a.angle(b), norm: a.cross(b).norm)
  }

}

func +(l: M3S, r: M3S) -> M3S { return M3S(l.m00 + r.m00, l.m01 + r.m01, l.m02 + r.m02, l.m10 + r.m10, l.m11 + r.m11, l.m12 + r.m12, l.m20 + r.m20, l.m21 + r.m21, l.m22 + r.m22) }
func -(l: M3S, r: M3S) -> M3S { return M3S(l.m00 - r.m00, l.m01 - r.m01, l.m02 - r.m02, l.m10 - r.m10, l.m11 - r.m11, l.m12 - r.m12, l.m20 - r.m20, l.m21 - r.m21, l.m22 - r.m22) }
func *(m: M3S, s: F32) -> M3S { return M3S(m.m00 * s, m.m01 * s, m.m02 * s, m.m10 * s, m.m11 * s, m.m12 * s, m.m20 * s, m.m21 * s, m.m22 * s) }
func /(m: M3S, s: F32) -> M3S { return M3S(m.m00 / s, m.m01 / s, m.m02 / s, m.m10 / s, m.m11 / s, m.m12 / s, m.m20 / s, m.m21 / s, m.m22 / s) }

func *(l: M3S, r: M3S) -> M3S { return M3S(
  (l.m00 * r.m00) + (l.m10 * r.m01) + (l.m20 * r.m02),
  (l.m01 * r.m00) + (l.m11 * r.m01) + (l.m21 * r.m02),
  (l.m02 * r.m00) + (l.m12 * r.m01) + (l.m22 * r.m02),
  (l.m00 * r.m10) + (l.m10 * r.m11) + (l.m20 * r.m12),
  (l.m01 * r.m10) + (l.m11 * r.m11) + (l.m21 * r.m12),
  (l.m02 * r.m10) + (l.m12 * r.m11) + (l.m22 * r.m12),
  (l.m00 * r.m20) + (l.m10 * r.m21) + (l.m20 * r.m22),
  (l.m01 * r.m20) + (l.m11 * r.m21) + (l.m21 * r.m22),
  (l.m02 * r.m20) + (l.m12 * r.m21) + (l.m22 * r.m22)
)}

func *(l: M3S, r: V3S) -> V3S { return V3S(
  (l.m00 * r.x) + (l.m10 * r.y) + (l.m20 * r.z),
  (l.m01 * r.x) + (l.m11 * r.y) + (l.m21 * r.z),
  (l.m02 * r.x) + (l.m12 * r.y) + (l.m22 * r.z)
)}

struct M3D: Printable {
  var m00, m01, m02, m10, m11, m12, m20, m21, m22: F64
  init(_ m00: F64, _ m01: F64, _ m02: F64, _ m10: F64, _ m11: F64, _ m12: F64, _ m20: F64, _ m21: F64, _ m22: F64) {
    self.m00 = m00
    self.m01 = m01
    self.m02 = m02
    self.m10 = m10
    self.m11 = m11
    self.m12 = m12
    self.m20 = m20
    self.m21 = m21
    self.m22 = m22
  } // init with elements in column major order.

  init(_ c0: V3D, _ c1: V3D, _ c2: V3D) {
    self.init(c0.x, c0.y, c0.z, c1.x, c1.y, c1.z, c2.x, c2.y, c2.z)
  } // init with column vectors.

  var description: String { return "M3D(\(m00), \(m01), \(m02), \(m10), \(m11), \(m12), \(m20), \(m21), \(m22))" }
  var c0: V3D { return V3D(m00, m01, m02) }
  var c1: V3D { return V3D(m10, m11, m12) }
  var c2: V3D { return V3D(m20, m21, m22) }
  var r0: V3D { return V3D(m00, m10, m20) }
  var r1: V3D { return V3D(m01, m11, m21) }
  var r2: V3D { return V3D(m02, m12, m22) }
  static let zero = M3D(0, 0, 0, 0, 0, 0, 0, 0, 0)
  static let ident = M3D(1, 0, 0, 0, 1, 0, 0, 0, 1)
  static func scale(x: F64, y: F64, z: F64) -> M3D { return M3D(x, 0, 0, 0, y, 0, 0, 0, z) }

  static func rotX(theta: F64) -> M3D { return M3D(
              1,           0,           0,
              0,  cos(theta),  sin(theta),
              0, -sin(theta),  cos(theta)
  )}

  static func rotY(theta: F64) -> M3D { return M3D(
     cos(theta),           0, -sin(theta),
              0,           1,           0,
     sin(theta),           0,  cos(theta)
  )}

  static func rotZ(theta: F64) -> M3D { return M3D(
     cos(theta),  sin(theta),           0,
    -sin(theta),  cos(theta),           0,
              0,           0,           1
  )}

  static func rot(#theta: F64, norm: V3D) -> M3D {
    let _cos = cos(theta)
    let _cosp = 1 - _cos
    let _sin = sin(theta)
    return M3D(
      _cos + _cosp * norm.x * norm.x,
      _cosp * norm.x * norm.y + norm.z * _sin,
      _cosp * norm.x * norm.z - norm.y * _sin,
      _cosp * norm.x * norm.y - norm.z * _sin,
      _cos + _cosp * norm.y * norm.y,
      _cosp * norm.y * norm.z + norm.x * _sin,
      _cosp * norm.x * norm.z + norm.y * _sin,
      _cosp * norm.y * norm.z - norm.x * _sin,
      _cos + _cosp * norm.z * norm.z
  )}

  static func rot(a: V3D, _ b: V3D) -> M3D {
    return rot(theta: a.angle(b), norm: a.cross(b).norm)
  }

}

func +(l: M3D, r: M3D) -> M3D { return M3D(l.m00 + r.m00, l.m01 + r.m01, l.m02 + r.m02, l.m10 + r.m10, l.m11 + r.m11, l.m12 + r.m12, l.m20 + r.m20, l.m21 + r.m21, l.m22 + r.m22) }
func -(l: M3D, r: M3D) -> M3D { return M3D(l.m00 - r.m00, l.m01 - r.m01, l.m02 - r.m02, l.m10 - r.m10, l.m11 - r.m11, l.m12 - r.m12, l.m20 - r.m20, l.m21 - r.m21, l.m22 - r.m22) }
func *(m: M3D, s: F64) -> M3D { return M3D(m.m00 * s, m.m01 * s, m.m02 * s, m.m10 * s, m.m11 * s, m.m12 * s, m.m20 * s, m.m21 * s, m.m22 * s) }
func /(m: M3D, s: F64) -> M3D { return M3D(m.m00 / s, m.m01 / s, m.m02 / s, m.m10 / s, m.m11 / s, m.m12 / s, m.m20 / s, m.m21 / s, m.m22 / s) }

func *(l: M3D, r: M3D) -> M3D { return M3D(
  (l.m00 * r.m00) + (l.m10 * r.m01) + (l.m20 * r.m02),
  (l.m01 * r.m00) + (l.m11 * r.m01) + (l.m21 * r.m02),
  (l.m02 * r.m00) + (l.m12 * r.m01) + (l.m22 * r.m02),
  (l.m00 * r.m10) + (l.m10 * r.m11) + (l.m20 * r.m12),
  (l.m01 * r.m10) + (l.m11 * r.m11) + (l.m21 * r.m12),
  (l.m02 * r.m10) + (l.m12 * r.m11) + (l.m22 * r.m12),
  (l.m00 * r.m20) + (l.m10 * r.m21) + (l.m20 * r.m22),
  (l.m01 * r.m20) + (l.m11 * r.m21) + (l.m21 * r.m22),
  (l.m02 * r.m20) + (l.m12 * r.m21) + (l.m22 * r.m22)
)}

func *(l: M3D, r: V3D) -> V3D { return V3D(
  (l.m00 * r.x) + (l.m10 * r.y) + (l.m20 * r.z),
  (l.m01 * r.x) + (l.m11 * r.y) + (l.m21 * r.z),
  (l.m02 * r.x) + (l.m12 * r.y) + (l.m22 * r.z)
)}

struct M4S: Printable {
  var m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33: F32
  init(_ m00: F32, _ m01: F32, _ m02: F32, _ m03: F32, _ m10: F32, _ m11: F32, _ m12: F32, _ m13: F32, _ m20: F32, _ m21: F32, _ m22: F32, _ m23: F32, _ m30: F32, _ m31: F32, _ m32: F32, _ m33: F32) {
    self.m00 = m00
    self.m01 = m01
    self.m02 = m02
    self.m03 = m03
    self.m10 = m10
    self.m11 = m11
    self.m12 = m12
    self.m13 = m13
    self.m20 = m20
    self.m21 = m21
    self.m22 = m22
    self.m23 = m23
    self.m30 = m30
    self.m31 = m31
    self.m32 = m32
    self.m33 = m33
  } // init with elements in column major order.

  init(_ c0: V4S, _ c1: V4S, _ c2: V4S, _ c3: V4S) {
    self.init(c0.x, c0.y, c0.z, c0.w, c1.x, c1.y, c1.z, c1.w, c2.x, c2.y, c2.z, c2.w, c3.x, c3.y, c3.z, c3.w)
  } // init with column vectors.

  var description: String { return "M4S(\(m00), \(m01), \(m02), \(m03), \(m10), \(m11), \(m12), \(m13), \(m20), \(m21), \(m22), \(m23), \(m30), \(m31), \(m32), \(m33))" }
  var c0: V4S { return V4S(m00, m01, m02, m03) }
  var c1: V4S { return V4S(m10, m11, m12, m13) }
  var c2: V4S { return V4S(m20, m21, m22, m23) }
  var c3: V4S { return V4S(m30, m31, m32, m33) }
  var r0: V4S { return V4S(m00, m10, m20, m30) }
  var r1: V4S { return V4S(m01, m11, m21, m31) }
  var r2: V4S { return V4S(m02, m12, m22, m32) }
  var r3: V4S { return V4S(m03, m13, m23, m33) }
  static let zero = M4S(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  static let ident = M4S(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
  static func scale(x: F32, y: F32, z: F32, w: F32) -> M4S { return M4S(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, w) }

  static func rotX(theta: F32) -> M4S { return M4S(
              1,           0,           0,           0,
              0,  cos(theta),  sin(theta),           0,
              0, -sin(theta),  cos(theta),           0,
              0,           0,           0,           1
  )}

  static func rotY(theta: F32) -> M4S { return M4S(
     cos(theta),           0, -sin(theta),           0,
              0,           1,           0,           0,
     sin(theta),           0,  cos(theta),           0,
              0,           0,           0,           1
  )}

  static func rotZ(theta: F32) -> M4S { return M4S(
     cos(theta),  sin(theta),           0,           0,
    -sin(theta),  cos(theta),           0,           0,
              0,           0,           1,           0,
              0,           0,           0,           1
  )}

  static func rot(#theta: F32, norm: V4S) -> M4S {
    let _cos = cos(theta)
    let _cosp = 1 - _cos
    let _sin = sin(theta)
    return M4S(
      _cos + _cosp * norm.x * norm.x,
      _cosp * norm.x * norm.y + norm.z * _sin,
      _cosp * norm.x * norm.z - norm.y * _sin,
      0,
      _cosp * norm.x * norm.y - norm.z * _sin,
      _cos + _cosp * norm.y * norm.y,
      _cosp * norm.y * norm.z + norm.x * _sin,
      0,
      _cosp * norm.x * norm.z + norm.y * _sin,
      _cosp * norm.y * norm.z - norm.x * _sin,
      _cos + _cosp * norm.z * norm.z,
      0,
      0,
      0,
      0,
      1
  )}

  static func rot(a: V4S, _ b: V4S) -> M4S {
    return rot(theta: a.angle(b), norm: a.cross(b).norm)
  }

}

func +(l: M4S, r: M4S) -> M4S { return M4S(l.m00 + r.m00, l.m01 + r.m01, l.m02 + r.m02, l.m03 + r.m03, l.m10 + r.m10, l.m11 + r.m11, l.m12 + r.m12, l.m13 + r.m13, l.m20 + r.m20, l.m21 + r.m21, l.m22 + r.m22, l.m23 + r.m23, l.m30 + r.m30, l.m31 + r.m31, l.m32 + r.m32, l.m33 + r.m33) }
func -(l: M4S, r: M4S) -> M4S { return M4S(l.m00 - r.m00, l.m01 - r.m01, l.m02 - r.m02, l.m03 - r.m03, l.m10 - r.m10, l.m11 - r.m11, l.m12 - r.m12, l.m13 - r.m13, l.m20 - r.m20, l.m21 - r.m21, l.m22 - r.m22, l.m23 - r.m23, l.m30 - r.m30, l.m31 - r.m31, l.m32 - r.m32, l.m33 - r.m33) }
func *(m: M4S, s: F32) -> M4S { return M4S(m.m00 * s, m.m01 * s, m.m02 * s, m.m03 * s, m.m10 * s, m.m11 * s, m.m12 * s, m.m13 * s, m.m20 * s, m.m21 * s, m.m22 * s, m.m23 * s, m.m30 * s, m.m31 * s, m.m32 * s, m.m33 * s) }
func /(m: M4S, s: F32) -> M4S { return M4S(m.m00 / s, m.m01 / s, m.m02 / s, m.m03 / s, m.m10 / s, m.m11 / s, m.m12 / s, m.m13 / s, m.m20 / s, m.m21 / s, m.m22 / s, m.m23 / s, m.m30 / s, m.m31 / s, m.m32 / s, m.m33 / s) }

func *(l: M4S, r: M4S) -> M4S { return M4S(
  (l.m00 * r.m00) + (l.m10 * r.m01) + (l.m20 * r.m02) + (l.m30 * r.m03),
  (l.m01 * r.m00) + (l.m11 * r.m01) + (l.m21 * r.m02) + (l.m31 * r.m03),
  (l.m02 * r.m00) + (l.m12 * r.m01) + (l.m22 * r.m02) + (l.m32 * r.m03),
  (l.m03 * r.m00) + (l.m13 * r.m01) + (l.m23 * r.m02) + (l.m33 * r.m03),
  (l.m00 * r.m10) + (l.m10 * r.m11) + (l.m20 * r.m12) + (l.m30 * r.m13),
  (l.m01 * r.m10) + (l.m11 * r.m11) + (l.m21 * r.m12) + (l.m31 * r.m13),
  (l.m02 * r.m10) + (l.m12 * r.m11) + (l.m22 * r.m12) + (l.m32 * r.m13),
  (l.m03 * r.m10) + (l.m13 * r.m11) + (l.m23 * r.m12) + (l.m33 * r.m13),
  (l.m00 * r.m20) + (l.m10 * r.m21) + (l.m20 * r.m22) + (l.m30 * r.m23),
  (l.m01 * r.m20) + (l.m11 * r.m21) + (l.m21 * r.m22) + (l.m31 * r.m23),
  (l.m02 * r.m20) + (l.m12 * r.m21) + (l.m22 * r.m22) + (l.m32 * r.m23),
  (l.m03 * r.m20) + (l.m13 * r.m21) + (l.m23 * r.m22) + (l.m33 * r.m23),
  (l.m00 * r.m30) + (l.m10 * r.m31) + (l.m20 * r.m32) + (l.m30 * r.m33),
  (l.m01 * r.m30) + (l.m11 * r.m31) + (l.m21 * r.m32) + (l.m31 * r.m33),
  (l.m02 * r.m30) + (l.m12 * r.m31) + (l.m22 * r.m32) + (l.m32 * r.m33),
  (l.m03 * r.m30) + (l.m13 * r.m31) + (l.m23 * r.m32) + (l.m33 * r.m33)
)}

func *(l: M4S, r: V4S) -> V4S { return V4S(
  (l.m00 * r.x) + (l.m10 * r.y) + (l.m20 * r.z) + (l.m30 * r.w),
  (l.m01 * r.x) + (l.m11 * r.y) + (l.m21 * r.z) + (l.m31 * r.w),
  (l.m02 * r.x) + (l.m12 * r.y) + (l.m22 * r.z) + (l.m32 * r.w),
  (l.m03 * r.x) + (l.m13 * r.y) + (l.m23 * r.z) + (l.m33 * r.w)
)}

struct M4D: Printable {
  var m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33: F64
  init(_ m00: F64, _ m01: F64, _ m02: F64, _ m03: F64, _ m10: F64, _ m11: F64, _ m12: F64, _ m13: F64, _ m20: F64, _ m21: F64, _ m22: F64, _ m23: F64, _ m30: F64, _ m31: F64, _ m32: F64, _ m33: F64) {
    self.m00 = m00
    self.m01 = m01
    self.m02 = m02
    self.m03 = m03
    self.m10 = m10
    self.m11 = m11
    self.m12 = m12
    self.m13 = m13
    self.m20 = m20
    self.m21 = m21
    self.m22 = m22
    self.m23 = m23
    self.m30 = m30
    self.m31 = m31
    self.m32 = m32
    self.m33 = m33
  } // init with elements in column major order.

  init(_ c0: V4D, _ c1: V4D, _ c2: V4D, _ c3: V4D) {
    self.init(c0.x, c0.y, c0.z, c0.w, c1.x, c1.y, c1.z, c1.w, c2.x, c2.y, c2.z, c2.w, c3.x, c3.y, c3.z, c3.w)
  } // init with column vectors.

  var description: String { return "M4D(\(m00), \(m01), \(m02), \(m03), \(m10), \(m11), \(m12), \(m13), \(m20), \(m21), \(m22), \(m23), \(m30), \(m31), \(m32), \(m33))" }
  var c0: V4D { return V4D(m00, m01, m02, m03) }
  var c1: V4D { return V4D(m10, m11, m12, m13) }
  var c2: V4D { return V4D(m20, m21, m22, m23) }
  var c3: V4D { return V4D(m30, m31, m32, m33) }
  var r0: V4D { return V4D(m00, m10, m20, m30) }
  var r1: V4D { return V4D(m01, m11, m21, m31) }
  var r2: V4D { return V4D(m02, m12, m22, m32) }
  var r3: V4D { return V4D(m03, m13, m23, m33) }
  static let zero = M4D(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
  static let ident = M4D(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
  static func scale(x: F64, y: F64, z: F64, w: F64) -> M4D { return M4D(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, w) }

  static func rotX(theta: F64) -> M4D { return M4D(
              1,           0,           0,           0,
              0,  cos(theta),  sin(theta),           0,
              0, -sin(theta),  cos(theta),           0,
              0,           0,           0,           1
  )}

  static func rotY(theta: F64) -> M4D { return M4D(
     cos(theta),           0, -sin(theta),           0,
              0,           1,           0,           0,
     sin(theta),           0,  cos(theta),           0,
              0,           0,           0,           1
  )}

  static func rotZ(theta: F64) -> M4D { return M4D(
     cos(theta),  sin(theta),           0,           0,
    -sin(theta),  cos(theta),           0,           0,
              0,           0,           1,           0,
              0,           0,           0,           1
  )}

  static func rot(#theta: F64, norm: V4D) -> M4D {
    let _cos = cos(theta)
    let _cosp = 1 - _cos
    let _sin = sin(theta)
    return M4D(
      _cos + _cosp * norm.x * norm.x,
      _cosp * norm.x * norm.y + norm.z * _sin,
      _cosp * norm.x * norm.z - norm.y * _sin,
      0,
      _cosp * norm.x * norm.y - norm.z * _sin,
      _cos + _cosp * norm.y * norm.y,
      _cosp * norm.y * norm.z + norm.x * _sin,
      0,
      _cosp * norm.x * norm.z + norm.y * _sin,
      _cosp * norm.y * norm.z - norm.x * _sin,
      _cos + _cosp * norm.z * norm.z,
      0,
      0,
      0,
      0,
      1
  )}

  static func rot(a: V4D, _ b: V4D) -> M4D {
    return rot(theta: a.angle(b), norm: a.cross(b).norm)
  }

}

func +(l: M4D, r: M4D) -> M4D { return M4D(l.m00 + r.m00, l.m01 + r.m01, l.m02 + r.m02, l.m03 + r.m03, l.m10 + r.m10, l.m11 + r.m11, l.m12 + r.m12, l.m13 + r.m13, l.m20 + r.m20, l.m21 + r.m21, l.m22 + r.m22, l.m23 + r.m23, l.m30 + r.m30, l.m31 + r.m31, l.m32 + r.m32, l.m33 + r.m33) }
func -(l: M4D, r: M4D) -> M4D { return M4D(l.m00 - r.m00, l.m01 - r.m01, l.m02 - r.m02, l.m03 - r.m03, l.m10 - r.m10, l.m11 - r.m11, l.m12 - r.m12, l.m13 - r.m13, l.m20 - r.m20, l.m21 - r.m21, l.m22 - r.m22, l.m23 - r.m23, l.m30 - r.m30, l.m31 - r.m31, l.m32 - r.m32, l.m33 - r.m33) }
func *(m: M4D, s: F64) -> M4D { return M4D(m.m00 * s, m.m01 * s, m.m02 * s, m.m03 * s, m.m10 * s, m.m11 * s, m.m12 * s, m.m13 * s, m.m20 * s, m.m21 * s, m.m22 * s, m.m23 * s, m.m30 * s, m.m31 * s, m.m32 * s, m.m33 * s) }
func /(m: M4D, s: F64) -> M4D { return M4D(m.m00 / s, m.m01 / s, m.m02 / s, m.m03 / s, m.m10 / s, m.m11 / s, m.m12 / s, m.m13 / s, m.m20 / s, m.m21 / s, m.m22 / s, m.m23 / s, m.m30 / s, m.m31 / s, m.m32 / s, m.m33 / s) }

func *(l: M4D, r: M4D) -> M4D { return M4D(
  (l.m00 * r.m00) + (l.m10 * r.m01) + (l.m20 * r.m02) + (l.m30 * r.m03),
  (l.m01 * r.m00) + (l.m11 * r.m01) + (l.m21 * r.m02) + (l.m31 * r.m03),
  (l.m02 * r.m00) + (l.m12 * r.m01) + (l.m22 * r.m02) + (l.m32 * r.m03),
  (l.m03 * r.m00) + (l.m13 * r.m01) + (l.m23 * r.m02) + (l.m33 * r.m03),
  (l.m00 * r.m10) + (l.m10 * r.m11) + (l.m20 * r.m12) + (l.m30 * r.m13),
  (l.m01 * r.m10) + (l.m11 * r.m11) + (l.m21 * r.m12) + (l.m31 * r.m13),
  (l.m02 * r.m10) + (l.m12 * r.m11) + (l.m22 * r.m12) + (l.m32 * r.m13),
  (l.m03 * r.m10) + (l.m13 * r.m11) + (l.m23 * r.m12) + (l.m33 * r.m13),
  (l.m00 * r.m20) + (l.m10 * r.m21) + (l.m20 * r.m22) + (l.m30 * r.m23),
  (l.m01 * r.m20) + (l.m11 * r.m21) + (l.m21 * r.m22) + (l.m31 * r.m23),
  (l.m02 * r.m20) + (l.m12 * r.m21) + (l.m22 * r.m22) + (l.m32 * r.m23),
  (l.m03 * r.m20) + (l.m13 * r.m21) + (l.m23 * r.m22) + (l.m33 * r.m23),
  (l.m00 * r.m30) + (l.m10 * r.m31) + (l.m20 * r.m32) + (l.m30 * r.m33),
  (l.m01 * r.m30) + (l.m11 * r.m31) + (l.m21 * r.m32) + (l.m31 * r.m33),
  (l.m02 * r.m30) + (l.m12 * r.m31) + (l.m22 * r.m32) + (l.m32 * r.m33),
  (l.m03 * r.m30) + (l.m13 * r.m31) + (l.m23 * r.m32) + (l.m33 * r.m33)
)}

func *(l: M4D, r: V4D) -> V4D { return V4D(
  (l.m00 * r.x) + (l.m10 * r.y) + (l.m20 * r.z) + (l.m30 * r.w),
  (l.m01 * r.x) + (l.m11 * r.y) + (l.m21 * r.z) + (l.m31 * r.w),
  (l.m02 * r.x) + (l.m12 * r.y) + (l.m22 * r.z) + (l.m32 * r.w),
  (l.m03 * r.x) + (l.m13 * r.y) + (l.m23 * r.z) + (l.m33 * r.w)
)}

