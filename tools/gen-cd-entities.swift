// Â© 2015 George King. Permission to use this file is granted in license-qk.txt.

import CoreData


func genUserFile(path: String, entity: NSEntityDescription) {
  // generate an empty extension file for custom code.
  if let stream = streamTo(path) {
    print("  \(path)")
    let name = entity.managedObjectClassName
    stream.writeLines(
      "//",
      "",
      "import CoreData",
      "",
      "extension \(name) {",
      "",
      "}")
  } else {
    fatalError("could not write file: \(path)")
  }
}


func genBaseFile(path: String, entity: NSEntityDescription) {
  // generate a class definition with standard behavior;
  // this file is intended to be overwritten as the model changes.
  if let stream = streamTo(path) {
    print("  \(path)")
    let name = entity.managedObjectClassName
    let superName = (entity.superentity?.managedObjectClassName).or("NSManagedObject")
    stream.writeLines(
      "// Generated by gen-cd-entities; DO NOT EDIT THIS FILE BY HAND.",
      "",
      "import Foundation",
      "import CoreData",
      "",
      "@objc(\(name))",
      "class \(name): \(superName) {\n")

    let superPropNames = (entity.superentity?.propNames).or(Set<String>())

    stream.writeLn("  // attributes.")
    for a in entity.attrs {
      if superPropNames.contains(a.name) {
        continue
      }
      stream.writeLn("\n  @NSManaged var \(a.name): \(a.typeName)")
      if let vtn = a.valTypeName {
        stream.writeLines(
          "  var \(a.name)Val: \(vtn) {",
          "    get {",
          "      return \(a.name).\(a.valAccessorName!)Value",
          "    }",
          "    set {",
          "      \(a.name) = NSNumber(\(a.valAccessorName!): newValue)",
          "    }",
          "  }")
      }
    }

    stream.writeLn("\n  // relationships.\n")
    for r in entity.rels {
      stream.writeLn("  @NSManaged var \(r.name): \(r.typeName)")
    }

    stream.writeLn("\n  // json.\n")
    stream.writeLn("  func updateWithJson(json: NSDictionary) -> NSError? {")
    for a in entity.attrs {
      stream.writeLines(
        "    if let u = json.objectForKey(\"\(a.name)\") {",
        "      if let v = u as? \(a.typeName) {",
        "        \(a.name) = v",
        "      } else {",
        "        return NSError(\"\(entity.name!).updateWithJson: value for key has incorrect type: \\(u.dynamicType)\")",
        "      }",
        "    }")
      if !a.optional {
        stream.writeLines(
          "    else {",
          "      return NSError(\"\(entity.name!).updateWithJson: missing value for key: \(a.name)\")",
          "    }")
      }
    }

    for _ in entity.rels {
      //stream.writeLines("  @NSManaged var \(r.name): \(r.typeName)")
    }

    stream.writeLines(
      "    ",
      "    return nil",
      "  }")

    stream.write("}\n")
  } else {
    fatalError("could not write file: \(path)")
  }
}

func generate(path: String) {
  print("path: \(path):")
  
  let dir = path.withoutPathExt
  let dirGen = dir + "-gen"
  let momdPath = dir + ".momd"

  if isPathFileOrDir(momdPath) {
    print("removing momd: \(momdPath)")
    do { try removeFileOrDir(momdPath) }
    catch let e { fail("could not remove existing momd: \(e)") }
  }

  print("compiling to: \(momdPath)")

  let momcTask = NSTask()
  momcTask.launchPath = "/usr/bin/xcrun"
  momcTask.arguments = ["-sdk", "macosx", "momc", path, momdPath]
  momcTask.launch()
  momcTask.waitUntilExit()
  check(momcTask.terminationStatus == 0, "momc failed")
  
  let m = NSManagedObjectModel(path: momdPath)
  check(m != nil, "model failed to load: \(momdPath)")

  if isPathFileOrDir(dirGen) {
    do { try removeFileOrDir(dirGen) }
    catch let e {"could not remove generated model dir: \(dirGen); \(e)" }
  }
  do { try createDir(dirGen) }
  catch let e { "could not create generated model dir: \(dirGen); \(e)" }

  for e in m!.entities as [NSEntityDescription] {
    let n = e.name!
    let userPath = "\(dir)/\(n).swift"
    let basePath = "\(dirGen)/\(n)-gen.swift"
    if !isPathFile(userPath) {
      genUserFile(userPath, entity: e)
    }
    genBaseFile(basePath, entity: e)
  }
}

func main(args: [String]) {
  check(args.count == 1, "expects a single argument: path to .xcdatamodeld directory.")
  let path_rel = args[0]
  print("r \(path_rel)")
  if let path = absolutePath(path_rel) {
    generate(path)
  } else {
    fatalError("path does not exist: \(path_rel)")
  }
}
