// Â© 2015 George King. Permission to use this file is granted in license-qk.txt.


import CoreData

func genUserFile(path: String, e: NSEntityDescription) {
  // generate an empty extension file for custom code.
  if let stream = streamTo(path) {
    println("  \(path)")
    let name = e.managedObjectClassName
    stream.writeLines(
      "//",
      "",
      "import CoreData",
      "",
      "extension \(name) {",
      "",
      "}")
  } else {
    fatalError("could not write file: \(path)")
  }
}


func genBaseFile(path: String, e: NSEntityDescription) {
  // generate a class definition with standard behavior;
  // this file is intended to be overwritten as the model changes.
  if let stream = streamTo(path) {
    println("  \(path)")
    let name = e.managedObjectClassName
    let superName = (e.superentity?.managedObjectClassName).or("NSManagedObject")
    stream.writeLines(
      "// Generated by gen-cd-entities; DO NOT EDIT THIS FILE BY HAND.",
      "",
      "import Foundation",
      "import CoreData",
      "",
      "@objc(\(name))",
      "class \(name): \(superName) {\n")

    let superPropNames = (e.superentity?.propNames).or(Set<String>())

    stream.writeLn("  // attributes.")
    for a in e.attrs {
      if superPropNames.contains(a.name) {
        continue
      }
      stream.writeLn("\n  @NSManaged var \(a.name): \(a.typeName)")
      if let vtn = a.valTypeName {
        stream.writeLines(
          "  var \(a.name)Val: \(vtn) {",
          "    get {",
          "      return \(a.name).\(a.valAccessorName!)Value",
          "    }",
          "    set {",
          "      \(a.name) = NSNumber(\(a.valAccessorName!): newValue)",
          "    }",
          "  }")
      }
    }

    stream.writeLn("\n  // relationships.\n")
    for r in e.rels {
      stream.writeLn("  @NSManaged var \(r.name): \(r.typeName)")
    }

    stream.writeLn("\n  // json.\n")
    stream.writeLn("  func updateWithJson(json: NSDictionary) -> NSError? {")
    for a in e.attrs {
      stream.writeLines(
        "    if let u = json.objectForKey(\"\(a.name)\") {",
        "      if let v = u as? \(a.typeName) {",
        "        \(a.name) = v",
        "      } else {",
        "        return NSError(\"\(e.name!).updateWithJson: value for key has incorrect type: \\(u.dynamicType)\")",
        "      }",
        "    }")
      if !a.optional {
        stream.writeLines(
          "    else {",
          "      return NSError(\"\(e.name!).updateWithJson: missing value for key: \(a.name)\")",
          "    }")
      }
    }

    for r in e.rels {
      //stream.writeLines("  @NSManaged var \(r.name): \(r.typeName)")
    }

    stream.writeLines(
      "    ",
      "    return nil",
      "  }")

    stream.write("}\n")
  } else {
    fatalError("could not write file: \(path)")
  }
}

func generate(path: String) {
  println("path: \(path):")
  
  let dir = path.withoutPathExt()
  let dirGen = dir + "-gen"
  let momdPath = dir + ".momd"

  if isPathFileOrDir(momdPath) {
    println("removing momd: \(momdPath)")
    check(removeFileOrDir(momdPath), "could not remove existing momd")
  }

  println("compiling to: \(momdPath)")

  let momcTask = NSTask()
  momcTask.launchPath = "/usr/bin/xcrun"
  momcTask.arguments = ["-sdk", "macosx", "momc", path, momdPath]
  momcTask.launch()
  momcTask.waitUntilExit()
  check(momcTask.terminationStatus == 0, "momc failed")
  
  let m = NSManagedObjectModel(path: momdPath)
  check(m != nil, "model failed to load: \(momdPath)")

  if isPathFileOrDir(dirGen) {
    check(removeFileOrDir(dirGen), "could not remove generated model dir: \(dirGen)")
  }
  check(createDir(dirGen), "could not create generated model dir: \(dirGen)")

  for e in m!.entities as [NSEntityDescription] {
    let n = e.name!
    let userPath = "\(dir)/\(n).swift"
    let basePath = "\(dirGen)/\(n)-gen.swift"
    if !isPathFile(userPath) {
      genUserFile(userPath, e)
    }
    genBaseFile(basePath, e)
  }
}

func main(args: [String]) {
  check(args.count == 1, "expects a single argument: path to .xcdatamodeld directory.")
  let path_rel = args[0]
  println("r \(path_rel)")
  if let path = absolutePath(path_rel) {
    generate(path)
  } else {
    fatalError("path does not exist: \(path_rel)")
  }
}
