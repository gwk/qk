// Â© 2015 George King. Permission to use this file is granted in license-qk.txt.
// This file is generated by gen-vec.py.
  
import Darwin
import SceneKit


extension V3 : VecType3, FloatVecType, CustomStringConvertible, JsonArrayInitable {
  typealias Scalar = Flt
  typealias FloatType = Flt
  typealias VSType = V3S
  typealias VDType = V3D
  typealias VU8Type = V3U8
  init(_ v: V3S) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  init(_ v: V3D) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  init(_ v: V3I) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  init(_ v: V3U8) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  init(_ v: V4S) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  init(_ v: V4D) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  init(_ v: V4I) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  init(_ v: V4U8) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  init(_ v: V2, z: Scalar) {
    self.init(v.x, v.y, z)
  }
  init(jsonArray: JsonArray) throws {
    if jsonArray.count > 3 {
      throw Json.Error.ExcessEl(index: 3, exp: V3.self, json: jsonArray.raw)
    }
    self.init(try jsonArray.el(0).conv() as Flt, try jsonArray.el(1).conv() as Flt, try jsonArray.el(2).conv() as Flt)
  }

  static let zero = V3(0, 0, 0)
  static let unitX = V3(1, 0, 0)
  static let unitY = V3(0, 1, 0)
  static let unitZ = V3(0, 0, 1)
  public var description: String { return "V3(\(x), \(y), \(z))" }
  var vs: V3S { return V3S(F32(x), F32(y), F32(z)) }
  var vd: V3D { return V3D(F64(x), F64(y), F64(z)) }
  var sqrLen: FloatType { return (FloatType(x).sqr + FloatType(y).sqr + FloatType(z).sqr) }
  var aspect: FloatType { return FloatType(x) / FloatType(y) }
  var r: Scalar {
    get { return x }
    set { x = newValue }
  }
  var g: Scalar {
    get { return y }
    set { y = newValue }
  }
  var b: Scalar {
    get { return z }
    set { z = newValue }
  }

  var allNormal: Bool { return x.isNormal && y.isNormal && z.isNormal }
  var allFinite: Bool { return x.isFinite && y.isFinite && z.isFinite }
  var allZero: Bool { return x.isNormal && y.isNormal && z.isNormal }
  var anySubnormal: Bool { return x.isSubnormal || y.isSubnormal || z.isSubnormal}
  var anyInfite: Bool { return x.isInfinite || y.isInfinite || z.isInfinite}
  var anyNaN: Bool { return x.isNaN || y.isNaN || z.isNaN}
  var norm: V3 { return self / self.len }
  var clampToUnit: V3 { return V3(clamp(x, min: 0, max: 1), clamp(y, min: 0, max: 1), clamp(z, min: 0, max: 1)) }
  var toU8Pixel: VU8Type { return VU8Type(U8(clamp(x * 255, min: 0, max: 255)), U8(clamp(y * 255, min: 0, max: 255)), U8(clamp(z * 255, min: 0, max: 255))) }
  var heading: Scalar { return atan2(y, x) }

  func dot(b: V3) -> Scalar { return (x * b.x) + (y * b.y) + (z * b.z) }
  func angle(b: V3) -> Scalar { return acos(self.dot(b) / (self.len * b.len)) }
  func lerp(b: V3, _ t: Scalar) -> V3 { return self * (1 - t) + b * t }

  func cross(b: V3) -> V3 { return V3(
  y * b.z - z * b.y,
  z * b.x - x * b.z,
  x * b.y - y * b.x
)}

}

func +(a: V3, b: V3) -> V3 { return V3(a.x + b.x, a.y + b.y, a.z + b.z) }
func -(a: V3, b: V3) -> V3 { return V3(a.x - b.x, a.y - b.y, a.z - b.z) }
func *(a: V3, b: V3) -> V3 { return V3(a.x * b.x, a.y * b.y, a.z * b.z) }
func /(a: V3, b: V3) -> V3 { return V3(a.x / b.x, a.y / b.y, a.z / b.z) }
func +(a: V3, s: Flt) -> V3 { return V3(a.x + s, a.y + s, a.z + s) }
func -(a: V3, s: Flt) -> V3 { return V3(a.x - s, a.y - s, a.z - s) }
func *(a: V3, s: Flt) -> V3 { return V3(a.x * s, a.y * s, a.z * s) }
func /(a: V3, s: Flt) -> V3 { return V3(a.x / s, a.y / s, a.z / s) }

